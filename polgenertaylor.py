# -*- coding: utf-8 -*-
"""PolGenerTaylor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RAUkonvTftN0a1JDnnpwp6uY4BFWXRAD
"""

from sympy import *
from sympy.matrices import Matrix
"""
FUNIONES:
- hallaPol(fun,conjunto,clase): devuelve la lista unitaria con una tupla con el polinomio.
-hallaPolAMano(): lo mismo, pero se introduce la función con LaTeX, el conjunto y la clase a mano. NO COMPROBADA
-getLatex(fun,conjunto,clase): Devuelve el código latex del polinomio. 
"""
#ES MUUY IMPORTANTE QUE CUANDO SE DEFINA LA FUNCIÓN, LA VARIABLE TIENE QUE SER
#DEFINIDA COMO x = symbols("x")


#FUNCIÓN PARA CREAR EL CONJUNTO DE PUNTOS A MANO.
def creaConjunto():
  num = int(input("Introduce el número de puntos que quieres que tenga el conjunto: "))
  conjunto = []
  i = 0
  while i < num:
    xi = float(input("Introduce el número: "))
    conjunto.append(xi)
    i += 1
  return conjunto


#CODIGO PARA CREAR LOS VECTORES Y LAS MATRICES
#Esto crea las filas de las matrices A_i
def creaVectorDeMatriz(grado,punto,vecesDeriva):
  x = symbols("x")
  v = []
  for j in range(grado+1):
    elem = diff(x**j,x,vecesDeriva)
    elem = elem.subs(x,punto)
    v.append(elem)
  return v


#Funcion para crear las matrices A_i
def creaMatrizI(grado, conjunto, vecesDeriva):
  lista = []
  for punto in conjunto:
    v = creaVectorDeMatriz(grado,punto,vecesDeriva)
    lista.append(v)
  matriz = Matrix(lista)
  return matriz


#Esto hace la matriz de todo el sistema
def superMatriz(grado, conjunto, clase):
  M = Matrix()
  for j in range(clase+1):
    m = creaMatrizI(grado,conjunto,j)
    M = Matrix.vstack(M,m)
  return M


#HALLAR EL VECTOR SOLUCIÓN
#La variable de fun debe ser nombrada como x. Esta funcion crea la parte del vector asociada a cada derivada
def solI(fun, conjunto, vecesDeriva):
  v = []
  fun_sol = diff(fun, x, vecesDeriva)
  for punto in conjunto:
    elem = fun_sol.subs(x, punto)
    v.append(elem)
  return Matrix(v)


#Esto crea todo el vector. Concatena en el orden correcto los minivectores de arriba
def solucion(fun,conjunto,clase):
  sol = Matrix()
  for j in range(clase+1):
    v = solI(fun,conjunto,j)
    sol = Matrix.vstack(sol,v)
  return sol


#HALLA EL POLINOMIO DÁNDOSELE UNA FUNCIÓN, EL CONJUNTO Y LA CLASE.
def hallaPol(fun, conjunto, clase):
  if clase <0 or len(conjunto) == 0:
    raise Exception("Has puesto números erróneos.")
  elif clase == 0:
    raise Exception("Se trata de un problema de interpolación polinómica")
  elif len(conjunto) == 1:
    raise Exception("Se trata del polinomio de Taylor")
  else:
    deg = len(conjunto)*(clase + 1) -1
    A = superMatriz(deg, conjunto, clase)
    b = solucion(fun, conjunto, clase)
    terminos = linsolve((A,b))
    terminos = list(terminos)
    lista = []
    for elem in terminos[0]:
      lista.insert(0,elem)
    x = symbols("x")
    return Poly.from_list(lista, x)


#La idea es meter todo a mano. No se si la funcion parse_latex() va a afuncionar.
def hallaPolAMano():
  int(input("Indica la clase del polinomio: "))
  conjunto = creaConjunto()
  s = input("Introduce el código en LaTeX: ")
  s = parse_latex(s)
  res = hallaPol(s,conjunto, clase)
  return res


def getLatex(fun, conjunto, clase):
  poli = hallaPol(fun, conjunto, clase)
  expre = latex(poli)
  inicio_expre = expre[20::]
  inicio_expre = inicio_expre[::-1]
  while inicio_expre[0] != "x":
    inicio_expre = inicio_expre[1:]
  expre = inicio_expre[3:]
  expre = expre[::-1]
  extra = "P_{f,"+str(conjunto)+","+str(clase)+"} = "
  final = extra + expre
  print(final)